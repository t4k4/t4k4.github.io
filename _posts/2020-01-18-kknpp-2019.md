---
layout:     post
title:      KKNPP 2019
date:       2020-01-19 00:14:34
summary:    KKNPP 2019.
categories: Malware Analysis
thumbnail: Malware Analysis
tags:
 - APT
---

<p>分析时间：2019年11月</p>

<hr />

<h1>KKNPP遭受攻击事件时间线</h1>

<p>2019年10月28日，有用户在twitter上披露了上传到VT的一个样本，指出其中使用SMB将收集的数据共享到一个内网地址，并且用户名为KKNPP。KKNPP是Kudankulam Nuclear Power Plant，即库丹库拉姆核电站的简称，该样本的披露引发了热议。</p>

<p>随后，印度威胁情报分析师Pukhraj Singh转发推文确认，称发生了对KKNPP的“域控级别的访问”，此次攻击发生于2019年9月份，印度政府已知悉此事。</p>

<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image1.png" width="588" height="593" layout="responsive" alt="" class="mb3"></amp-img>
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image2.png" width="476" height="562" layout="responsive" alt="" class="mb3"></amp-img>
图 1 1 

<p>NPCIL10月29日发布的声明否认了KKNPP遭受攻击，并称“KKNPP与其他核电站控制系统是独立的，没有连接到互联网，任何针对核电站控制系统的网络攻击是不可能的。现在KKNPP Unit-1 & 2运行良好。”该声明只否认了核电站控制系统遭受攻击，未对核电站内其他系统的安全性进行说明。</p>
<p>随后，在10月30日，NPCIL重新发布声明，确认NPCIL系统中存在恶意软件，在2019年9月4日由印度CERT告知此事，并开展调查。调查结果显示受感染的电脑为管理用途，该电脑与关键内部网络隔离，核电系统未受影响。</p>
   
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image3.png" width="728" height="600" layout="responsive" alt="NPCIL发布的声明1" class="mb3"></amp-img>
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image4.png" width="547" height="704" layout="responsive" alt="NPCIL发布的声明2" class="mb3"></amp-img>
图 1 2 NPCIL发布的声明

<hr />

<h1>相关样本分析</h1>
<h2>Dtrack Dropper</h2>
表 2 1样本标签
<table>
    <tr>
        <td>MD5</td>
        <td>文件类型</td>
        <td>文件大小</td>
    </tr>
    <tr>
        <td>b7c3039203278bc289fd3756571bd468</td>
        <td>PE32 Executable</td>
        <td>1400KB</td>
    </tr>
    <tr>
        <td>4f8091a5513659b2980cb53578d3f798</td>
        <td>PE32 Executable</td>
        <td>820KB</td>
    </tr>
</table>

<h3>Dropper</h3>
<p>该Dropper程序是一个空壳程序，主要用于解密执行payload。Dropper程序在调用start()函数进行初始化时，调用execute_payload函数。execute_payload函数首先为payload分配内存，从当前可执行文件的特定偏移处读取数据到分配的内存中，数据偏移与数据长度存放在MS-DOS头部未使用的字段中，分别为文件头偏移的0x20和0x28；然后解密数据，得到第一阶段的shellcode。</p>
 
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image5.png" width="739" height="259" layout="responsive" alt="执行payload函数位于CRTStartup过程中" class="mb3"></amp-img>
图 2 1 执行payload函数位于CRTStartup过程中

<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image6.png" width="872" height="253" layout="responsive" alt="第一阶段shellcode" class="mb3"></amp-img>
图 2 2 第一阶段shellcode

<p>第一阶段shellcode重复execute_payload函数过程，数据与长度偏移分别位于文件头的0x2c和0x30处，解密得到第二阶段数据，可以看到第二阶段数据为一个完整的可执行文件，shellcode读取PE头部信息，跳转到程序入口点开始执行。将该可执行文件dump后计算其MD5值，为4f8091a5513659b2980cb53578d3f798，即twitter用户此次披露的样本。</p>
 
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image7.png" width="915" height="272" layout="responsive" alt="第二阶段解密的数据" class="mb3"></amp-img>
图 2 3 第二阶段解密的数据
<p>查看execute_payload函数的引用，发现整个程序内共有60处对该函数的引用，且大多位于系统函数内，恶意软件作者通过这种方式进行隐藏，并能够保证嵌入的代码被执行。</p>
 
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image8.png" width="715" height="349" layout="responsive" alt="函数引用" class="mb3"></amp-img>
图 2 4 函数引用

<h3>Payload</h3>

<p>该payload主要用于从被感染机器中收集信息并回传给攻击者控制的主机。</p>

<p>程序首先使用LoadLibraryA和GetProcAddress API获取所需的API地址，其中，获取API字符串的方法与卡巴斯基报告中Dtrack使用的方法相同，如图2-5所示。如果字符串以”CCS_”开始，则其后为目标字符串；否则，第一个字节为密钥，依次与其后的字节异或得到目标字符串。</p>
  
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image9.png" width="662" height="515" layout="responsive" alt="字符串获取函数，卡巴斯基报告" class="mb3"></amp-img>
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image10.png" width="405" height="455" layout="responsive" alt="字符串获取函数，此次Dtrack样本" class="mb3"></amp-img>
图 2 5 字符串获取函数，上图为卡巴斯基报告，下图为此次Dtrack样本

<p>然后程序通过注册表查询感染主机的RegisteredOwner、RegisteredOrganization以及InstallDate，获取设备MAC地址，使用这些信息计算生成8位设备指纹。</p>
 
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image11.png" width="871" height="317" layout="responsive" alt="查询注册表" class="mb3"></amp-img>
图 2 6 查询注册表

<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image12.png" width="545" height="467" layout="responsive" alt="计算设备指纹" class="mb3"></amp-img>
图 2 7 计算设备指纹

<p>之后，程序在%TEMP%目录下创建temp文件夹以及temp\[ip]文件夹，[ip]为程序获取的本机IP；收集感染主机的IP、进程、端口等信息分别记录到%TEMP%\temp目录下的res.ip等文件中，并收集火狐和Chrome浏览器的历史记录写入browser.his文件中；然后尝试连接172.22.22.156，10.2.114.1，172.22.22.5，10.2.4.1四个地址的80端口，并记录能够成功连接的IP和端口。</p>
 
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image13.png" width="523" height="137" layout="responsive" alt="payload收集的部分信息" class="mb3"></amp-img>
图 2 8 payload收集的部分信息

<p>接下来，程序收集所有磁盘下的目录及文件信息，加密压缩后写入到%TEMP%\temp\[ip]目录下的*.tmp（*为磁盘盘符）文件中，压缩密码为“dkwero38oerA^t@#”；将%TEMP%\temp目录下所有文件加密压缩后写入%TEMP%\~*MT.tmp（*为8位设备指纹）文件中，压缩密码为“abcd@123”；最后，删除%TEMP%\temp目录下所有文件，将最终文件通过SMB发送到静态编码的10.38.1.35（用户名为KKNPP\administrator，密码为su.controller5kk）的C:\Windows\Temp\MpLogs\目录下，并退出程序。</p>
 
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image14.png" width="843" height="244" layout="responsive" alt="通过SMB传输最终文件" class="mb3"></amp-img>
图 2 9 通过SMB传输最终文件

<h2>Dtrack RAT</h2>

表 2 2样本标签
<table>
    <tr>
        <td>MD5</td>
        <td>文件类型</td>
        <td>文件大小</td>
    </tr>
    <tr>
        <td>ebb52f45ff1483e82ff3258b7f086571</td>
        <td>PE32 Executable</td>
        <td>208KB</td>
    </tr>
    <tr>
        <td>acd7aafa65d0dc4bdb5f04940107087b</td>
        <td>PE32 Executable</td>
        <td>184KB</td>
    </tr>
    <tr>
        <td>d10781f6b0a420ba0a9addfa5411fd97</td>
        <td>PE32 Executable</td>
        <td>208KB</td>
    </tr>
</table>

<p>三个样本均为与此次攻击相关的样本，且功能类似，在此以第一个样本为例进行分析，MD5为acd7aafa65d0dc4bdb5f04940107087b。该样本的主要功能为从C2地址接收命令执行。样本中遗留了大量日志信息，日志文件为%TEMP%\ Execute_ 0116ad.log，并且包含大量加密字符串，解密时使用“rcmgmg3ny3pa”作为种子。</p>
 
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image15.png" width="480" height="317" layout="responsive" alt="样本中的日志信息" class="mb3"></amp-img>
图 2 10 样本中的日志信息
<p>程序首先重新定义API，解密API字符串，使用LoadLibrary和GetProcAddress API获取API地址。然后创建名为Global\opr7e5WVfX的互斥量，设置DACL保护进程，判断当前用户权限，最后通过CreateThread创建两个线程，分别为主线程和用于持久化的起始线程，其中起始线程根据设置，有多种持久化方式，每隔1小时运行一次。</p>
 
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image16.png" width="528" height="301" layout="responsive" alt="解密API字符串并获取API地址" class="mb3"></amp-img>
图 2 11 解密API字符串并获取API地址
<p>主线程为该RAT的主体部分。首先进行初始化工作，计算设备指纹，计算方法与MD5为4f8091a5513659b2980cb53578d3f798的payload相同；然后获取被感染主机IP地址，解密C2 URL，从%TEMP%目录下的eventib216.tmp和eventib217.tmp文件中读取初始的C2命令。</p>
 
<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image17.png" width="741" height="94" layout="responsive" alt="解密API字符串并获取API地址" class="mb3"></amp-img>
图 2 12 样本中静态编码的C2 URL

<p>对于每个C2 URL，主线程检查网页扩展名是否为.php，.jsp，.asp中的一个，如果不是，则通过其他算法获取C2 URL；然后从C2下载命令并解密，如果为新的命令，将命令写入eventib216.tmp和eventib217.tmp文件中，并执行相应动作。该样本中包含的C2命令如表2-3所示，与卡巴斯基报告中提及的Dtrack指令相同。</p>
表 2 3 C2命令说明
<table>
    <tr>
        <td>命令</td>
        <td>描述</td>
    </tr>
    <tr>
        <td>1003</td>
        <td>下载文件到被感染主机</td>
    </tr>
    <tr>
        <td>1005</td>
        <td>通过多种方式进行持久化</td>
    </tr>
    <tr>
        <td>1006</td>
        <td>上传文件</td>
    </tr>
    <tr>
        <td>1007</td>
        <td>收集所有磁盘上的文件信息</td>
    </tr>
    <tr>
        <td>1008</td>
        <td>收集指定磁盘上的文件信息</td>
    </tr>
    <tr>
        <td>1018</td>
        <td>设定新的进程睡眠间隔</td>
    </tr>
    <tr>
        <td>1023</td>
        <td>清除所有痕迹</td>
    </tr>
    <tr>
        <td>默认</td>
        <td>执行指定命令</td>
    </tr>
</table>

<amp-img src="{{ site.baseurl }}assets/images/kknpp2019/image18.png" width="813" height="255" layout="responsive" alt="解密API字符串并获取API地址" class="mb3"></amp-img>
图 2 13 卡巴斯基报告中的Dtrack C2命令
2.3	小结
<p>卡巴斯基对Dtrack Dropper的描述：“该dropper程序的加密payload嵌入在PE文件中，作为额外数据，而这些额外数据在正常执行过程中永远不会被用到。作为可执行文件的补丁，其解密程序在start()函数中，在WinMain()函数被调用之前开始。恶意软件作者将恶意代码嵌入到无害的可执行程序中，这些可执行程序可能是默认的Visual Studio MFC程序，也可能是其他程序。”经过分析，该dropper程序与卡巴斯基描述的Dtrack Dropper相似性极高，另外，payload中使用的获取字符串的函数与卡巴斯基报告中指出的函数完全相同，因此基本可以认为二者来自同一家族。</p>
<p>此外，Dtrack RAT中使用的计算指纹、收集磁盘文件信息等函数与2.1中的payload基本相同；C2命令与卡巴斯基报告中提及的Dtrack指令相同，基本可以认为多个样本来自同一组织。</p>